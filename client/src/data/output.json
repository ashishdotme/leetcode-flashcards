[{"path":"docs_algorithm_01-recurrence.md","slug":"01-recurrence","topic":"algorithm","title":"Recurrence","url":"https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/algorithm/01-recurrence.md","front":"What is recurrence","back":"An equation or inequality that describes a function in terms of its value on previous/smaller values"},{"path":"docs_array_03-first-missing-positive.md","slug":"03-first-missing-positive","topic":"array","title":"Two sum","url":"https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/03-first-missing-positive.md","front":"Given an unsorted integer array nums, find the smallest missing positive integer.\n\nInput: nums = [1,2,0]\nOutput: 3","back":"Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"},{"path":"docs_array_02-container-with-most-water.md","slug":"02-container-with-most-water","topic":"array","title":"Container with most water","url":"https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/02-container-with-most-water.md","front":"Given n non-negative integers a1, a2, ..., an, where each represents a point at coordinate (i, ai). n vertical lines are drawn such that the two endpoints of line i is at (i, ai) and (i, 0). Find two lines, which together with x-axis forms a container, such that the container contains the most water.","back":"Initially we can assume the result is 0. Then we scan from both sides. If leftHeight < rightHeight, move right and find a value that is greater than leftHeight. Similarily, if leftHeight > rightHeight, move left and find a value that is greater than rightHeight. Additionally, keep tracking the max value."},{"path":"docs_array_01-two-sum.md","slug":"01-two-sum","topic":"array","title":"Two sum","url":"https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/01-two-sum.md","front":"Given an array of integers, return indices of the two numbers such that they add up to a specific target.\n\n[2, 7, 11, 15], 9 => [0, 1]","back":"Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"},{"path":"docs_array_04-spiral-matrix.md","slug":"04-spiral-matrix","topic":"array","title":"Two sum","url":"https://github.com/ashishdotme/leetcode-flashcards/blob/master/docs/array/04-spiral-matrix.md","front":"Given an m x n matrix, return all elements of the matrix in spiral order.\n\nInput: matrix = [[1,2,3],[4,5,6],[7,8,9]]\nOutput: [1,2,3,6,9,8,7,4,5]","back":"Data Structure:\n- hashtable: maintain a mapping of each element in the array to its index\n\nAlgorithm: Two-pass Hash Table\n1. In the first iteration, add each element's value and its index to the table.\n2. In the second iteration, check if each element's complement (target - nums[i]) exists in the table.\n3. Beware that the complement must not be nums[i] itself.\n\nTime complexity: O(n)\nSpace complexity: O(n)"}]
